// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of org.kqed
//
// Copyright 2022 undefined <undefined>
//
// See LICENSE for details
"use strict";

const Tp = require('thingpedia');

const RSS_URL = "https://www.omnycontent.com/d/playlist/0af137ef-751e-4b19-a055-aaef00d2d578/87fdd794-f90e-4280-920f-ab89016e8062/d72d17c7-e1c8-4763-98eb-ab89016ed36a/podcast.rss";

const DEVICE_ERROR = {
    no_postcasts_available: 'no_podcasts_available',
    unsupported_version: 'unsupported_version',
    service_unavailable: 'service_unavailable'
};

function _removeHtmlCode(str) {
    return str.replace(/<[^>]*>?/gm, '');
}

async function fetchContent() {
    const blob = await Tp.Helpers.Http.get(RSS_URL).then(
        (result) => Tp.Helpers.Xml.parseString(result)
    ).then(
        (parsed) => {
            const podcasts = parsed.rss.channel[0];
            if (podcasts.item === undefined)
                throw new Error(DEVICE_ERROR.no_postcast_available);
            return podcasts.item.map((item) => {
                const title = _removeHtmlCode(item.title[0]);
                return ({
                    // id: new Tp.Value.Entity(item.guid[0]['_'], null),
                    id: new Tp.Value.Entity(title, null),
                    title: title,
                    description: _removeHtmlCode(item.description[0]),
                    link: item['media:content'][0]['$'].url,
                    date: new Date(item.pubDate[0]),
                    duration: Number(item['itunes:duration'][0])
                });
            });
        }).catch((err) => {
        if (err.code === 404)
            throw new Error("Invalid URL");
        else
            throw new Error(DEVICE_ERROR.service_unavailable);
    });
    return blob;
}

module.exports = class KqedDevice extends Tp.BaseDevice {
    constructor(engine, state) {
        super(engine, state);
        this._playedItems = new Set();
        /**
          * @type {{ uniqueId: string, timestamp: number }|null}
          */
        this._lastPlay = null;
    }

    _testMode() {
        return process.env.TEST_MODE === '1';
    }

    /**
     *
     * @param {string} blob
     * @returns
     */
    async _resolveShoutcastURL(blob) {
        const line = blob.split('\n').find((x) => x.startsWith('File'));
        if (!line) {
            console.log(`failed to parse shoutcast`, blob);
            throw new Error(`Cannot parse Shoutcast playlist`);
        }
        return line.replace(/^File[^=+]=/, '');
    }

    async _resolvePlayableURL(uriList) {
        const url = uriList.trim().split('\n')[0];
        // HACK...
        if (url.endsWith('m3u'))
            return this._resolvePlayableURL(await Tp.Helpers.Http.get(url));
        if (url.endsWith('pls'))
            return this._resolveShoutcastURL(await Tp.Helpers.Http.get(url));
        return url;
    }

    async _get_content() {
        const contents = await fetchContent();
        let url = "";
        let duration = 0;
        for (const item of contents) {
            if (!this._playedItems.has(item)) {
                this._playedItems.add(item);
                url = item.link;
                duration = item.duration;
                break;
            }
        }
        if (url.length) {
            return {url: url, duration: duration};
        } else {
            throw new Error(DEVICE_ERROR.no_postcasts_available);
        }
    }

    async do_kqed_play({}, env) {
        // HACK: prevent repeated calls to play from the same program
        // (generated by something like "play the radio")
        const now = Date.now();
        if (this._lastPlay && this._lastPlay.uniqueId === env.app.uniqueId && now - this._lastPlay.timestamp < 300000) {
            this._lastPlay.timestamp = now;
            return;
        }
        this._lastPlay = {
            uniqueId: env.app.uniqueId,
            timestamp: now
        };

        const item = await this._get_content();

        // const playable_link = await this._resolvePlayableURL(await Tp.Helpers.Http.get(item.url));
        const playable_link = item.url;
        console.log(`Playing from ${playable_link}`);

        if (this._testMode()) return;

        const engine = this.engine;
        if (engine.audio && engine.audio.playURLs) {
            if (!await engine.audio.checkCustomPlayer({ type: 'url' }, env.conversation))
                throw new Error(DEVICE_ERROR.unsupported_version);

            // play asynchronously: playing will call requestAudio on the audio controller,
            // which will wait until the agent is done speaking, so we must return here
            engine.audio.playURLs(this, [playable_link], env.conversation).catch((err) => {
                console.error(`Failed to play URL`, err);
            });
            return;
        }

        const audio_player = this.platform.getCapability('audio-player');
        console.log("audio-player");
        if (!audio_player) {
            throw new Error(DEVICE_ERROR.unsupported_version);
        } else {
            // const playable_link = this._http_post(url);
            try {
                audio_player.play(playable_link);
                return;
            } catch(err) {
                throw new Error(DEVICE_ERROR.service_unavailable);
            }
        }
    }

    async *get_kqed_podcasts() {
        try {
            const contents = await fetchContent();
            for (const item of contents)
                yield item;
        } catch(error) {
            throw new Error(DEVICE_ERROR.service_unavailable);
        }
    }
};